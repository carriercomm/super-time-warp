<!DOCTYPE html>
<html>
<head>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/shared/gj_constants.js"></script>
    <script src="/shared/gj_json.js"></script>
    <script src="pixi.js"></script>
    <style>
        body {
            background: #000;
        }
        #canvas-container {
            cursor: none !important;
            width: 800px;
            float: left;
        }
        #scores-container {
            float: left;
            /*background: white;*/
            width: 200px;
            height: 608px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="scores-container">
        <ul id="scores-list"></ul>
    </div>
</body>
<script>

    var socket;

    var scores = {};
    var scores_list = document.getElementById('scores-list');

    // Drawing ####################################################################

    var SCALE_FACTOR = 3;
    var VIEWPORT = { w: 800, h: 608 };

    var SCALE = new PIXI.Point(SCALE_FACTOR, SCALE_FACTOR);
    PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST;

    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0x66FF99);
    var root_container = new PIXI.DisplayObjectContainer();
    root_container.scale = SCALE;
    stage.addChild(root_container);

    var tile_container = null;

    var object_container = new PIXI.DisplayObjectContainer();
    root_container.addChild(object_container);

    var crosshairs = new PIXI.Sprite(PIXI.Texture.fromImage('assets/crosshairs.png'));
    crosshairs.anchor.x = 0.5;
    crosshairs.anchor.y = 0.5;
    root_container.addChild(crosshairs);

    // create a renderer instance
    var renderer = PIXI.autoDetectRenderer(VIEWPORT.w, VIEWPORT.h);

    // add the renderer view element to the DOM
    document.getElementById('canvas-container').appendChild(renderer.view);

    var textures = {};
    var sprites = {};
    var playerUI = {}; // object to hold local UI data

    // This array holds filepaths to all json files with sprite information
    var assetsToLoad = ['assets/tiles.json', 'assets/ui.json'];

    loader = new PIXI.AssetLoader(assetsToLoad);

    // The load is asynchronous, so wait for the go-ahead before starting
    loader.onComplete = ready.bind(this);
    loader.load();

    // Make sure the world is ready before opening the socket.
    function ready()
    {
        // Textures are loaded, so store them for later. This should become a larger set of maps
        textures = {
            player: 'tile_49',
            bullet: 'tile_33'
        };

        // Perform socket setup to start the game
        initSocket();
    }

    function initSprites(state) {

    }

    // Creates the tile_container and adds it to the root_container.  Cleans up old one if it exists.
    function initMap(map) {
        if (tile_container) {
            root_container.removeChild(tile_container);
        }
        tile_container = new PIXI.DisplayObjectContainer();
        root_container.addChildAt(tile_container, 0);

        var tiles = map.tiles;
        for (var i = 0; i < tiles.length; i++) {
            for (var j = 0; j < tiles[i].length; j++) {
                if (!tiles[i][j]) continue;

                // create a new Sprite using the texture
                var tile = new PIXI.Sprite.fromFrame('tile_'+tiles[i][j]);

                // move the sprite into position
                tile.position.x = j * 16;
                tile.position.y = i * 16;

                tile_container.addChild(tile);
            }
        }
    }

    function renderState(state) {
        var liveIds = [];

        for (var i = 0; i < state.objects.length; i++) {
            var object = state.objects[i];

            // TODO: figure out why objects are null
            if (!object) continue;

            liveIds.push(object.id);
            var sprite = sprites[object.id];

            if (!sprite) {

                var child_sprite = new PIXI.Sprite.fromFrame(textures[object.type]);

                // center the sprites anchor point
                child_sprite.anchor.x = 0.5;
                child_sprite.anchor.y = 0.5;

                sprite = new PIXI.DisplayObjectContainer();
                sprite.addChild(child_sprite);
                child_sprite.y = -object.h / 2;

                if (object.type == 'player') {

                    var texture = (object.id === socket.id ? 'arrow_big_' : 'arrow_') + object.color;
                    var pointer_sprite = new PIXI.Sprite.fromFrame(texture);

                    pointer_sprite.anchor.x = 0.5;
                    pointer_sprite.anchor.y = 0.5;

                    pointer_sprite.position.y = -object.h * 1.5;
                    sprite.addChild(pointer_sprite);
                }

                sprites[object.id] = sprite;
                object_container.addChild(sprite);

            }

            sprite.position.y = object.y;
            sprite.position.x = object.x;
            sprite.getChildAt(0).rotation = object.angle;

            if (object.type == 'player') {
                var score = object.kills + ' / ' + object.deaths;
                var li = scores[object.id];
                if (!li) {
                    li = document.createElement('li');
                    li.style.color = object.color;
                    li.innerHTML = object.color + ' : ' + score;
                    li.score = score;
                    scores_list.appendChild(li);
                    scores[object.id] = li;
                } else if (score != li.score) {
                    li.innerHTML = object.color + ' : ' + score;
                    li.score = score;
                }
            }

            // Center the camera around this client's player object.
            if (object.id === socket.id) {
                centerCamera(object, state.maps[state.era].tiles[0].length, state.maps[state.era].tiles.length);
            }
        }

        // Remove all the sprites which are tied to object IDs which are now missing.
        for (var k in sprites) {
            if (liveIds.indexOf(k) < 0) {
                object_container.removeChild(sprites[k]);
                delete sprites[k];
            }
        }

        // Remove scores of players that have left
        for (var k in scores) {
            if (liveIds.indexOf(k) < 0) {
                scores_list.removeChild(scores[k]);
                delete scores[k];
            }
        }

        // render the stage
        renderer.render(stage);
    }

    var mousePos = { x: 0, y: 0 };
    var worldPos = { x: 0, y: 0 };

    function centerCamera(point, mapWidth, mapHeight) {
        var cx = -point.x * SCALE_FACTOR + VIEWPORT.w / 2;
        var cy = -point.y * SCALE_FACTOR + VIEWPORT.h / 2;

        root_container.x += (cx - root_container.x) / 3;
        root_container.y += (cy - root_container.y) / 3;

        // Stop the camera at the boundaries
        if (root_container.x > 0) root_container.x = 0;
        if (root_container.y > 0) root_container.y = 0;
        var minx = -SCALE_FACTOR * mapWidth * gj_CONSTANTS.TILE_SIZE + VIEWPORT.w;
        var miny = -SCALE_FACTOR * mapHeight * gj_CONSTANTS.TILE_SIZE + VIEWPORT.h;
        if (root_container.x < minx) root_container.x = minx;
        if (root_container.y < miny) root_container.y = miny;

        var pos = screenPosToWorldCoordinates(mousePos);
        if (pos.x != worldPos.x || pos.y != worldPos.y) {
            worldPos = pos;
            onMouseMove(worldPos);
        }
    }

    function screenPosToWorldCoordinates(pos) {

        var x = (pos.x - root_container.x) / SCALE_FACTOR;
        var y = (pos.y - root_container.y) / SCALE_FACTOR;

        return { x: x, y: y };

    }

    function onMouseMove(pos) {
        crosshairs.x = pos.x;
        crosshairs.y = pos.y;
        socket.emit('msg input', { type: 'mousemove', x: pos.x, y: pos.y });
    }

    // Networking #################################################################

    function initSocket() {
        var latestState;
        socket = io();

        // Receiving state messages from the server -------------------

        socket.on('msg state', function(state) {
            latestState = state;
            initSprites(latestState);
            initMap(latestState.maps[latestState.era]);
            renderState(latestState);
        });

        socket.on('msg diff', function(diff) {
            var newState = gj_JSON.applyDiff(latestState, diff);
            if (newState.era !== latestState.era) {
                initMap(newState.maps[newState.era]);
            }
            latestState = newState;
            renderState(latestState);
        });

        // Handling inputs and sending them to the server -------------

        var keys = [];
        for (var key in gj_CONSTANTS.keys) {
            keys.push(gj_CONSTANTS.keys[key]);
        }

        window.onkeyup = function(e) {
            if (keys.indexOf(e.keyCode) > -1) {
                socket.emit('msg input', { type: 'keyup', key: e.keyCode });
            }
        };

        window.onkeydown = function(e) {
            if (keys.indexOf(e.keyCode) > -1) {
                socket.emit('msg input', { type: 'keydown', key: e.keyCode });
            }
        };

        renderer.view.onmousemove = function(e) {
            mousePos = { x: e.layerX, y: e.layerY };
            worldPos = screenPosToWorldCoordinates(mousePos);
            onMouseMove(worldPos);
        };

        renderer.view.onmousedown = function(e) {
            socket.emit('msg input', { type: 'mousedown' });
        };

        renderer.view.onmouseup = function(e) {
            socket.emit('msg input', { type: 'mouseup' });
        };

    }

</script>
</html>
